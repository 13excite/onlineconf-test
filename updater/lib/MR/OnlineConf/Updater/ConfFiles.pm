package MR::OnlineConf::Updater::ConfFiles;

use Mouse;

use JSON;
use CDB_File;
use File::Spec;
use POSIX qw/strftime/;

has dir => (
    is  => 'ro',
    isa => 'Str',
    required => 1,
);

has log => (
    is  => 'ro',
    isa => 'Log::Dispatch',
    required => 1,
);

has cdb => (
    is => 'ro',
    isa => 'Bool',
    default => 0,
);

has _data => (
    is  => 'ro',
    isa => 'HashRef',
    default => sub { {} },
);

sub update {
    my ($self, $tree, $modules) = @_;
    my @failed;

    # Dump modules
    foreach my $module (@$modules) {
        next if $module eq 'TREE';

        my $data = {};

        if (my $node = $tree->get("/onlineconf/module/$module")) {
            $data = $self->_walk_tree($node);
        }

        eval {
            $self->_dump_module($module, $data); 1;
        } or do {
            $self->log->error($@);
            push @failed, $module;
        };
    }

    # Dump TREE.conf
    my $data = $self->_walk_tree($tree->_root);

    eval {
        $self->_dump_module('TREE', $data); 1;
    } or do {
        $self->log->error($@);
        push @failed, 'TREE';
    };

    die sprintf "Failed to write modules: %s\n", join ', ', @failed if @failed;

    return;
}

sub _walk_tree {
    my ($self, $node) = @_;
    my %data;

    local $self->{seen_node}->{$node->id} = 1;

    foreach my $name (keys %{$node->children}) {
        my $child = $node->child($name);

        next if $self->{seen_node}->{$child->id};
        next if !$child || $self->{seen_node}->{$child->id};

        if (!$child->is_null) {
            if (defined(my $value = $child->value)) {
                if (ref $value) {
                    $data{"$name:JSON"} = eval {
                        JSON::to_json($value)
                    };
                } else {
                    $value = '' unless defined $value;
                    $value =~ s/\n/\\n/g;
                    $value =~ s/\r/\\r/g;
                    $data{$name} = $value;
                }
            }
        }

        my $child_data = $self->_walk_tree($child);

        foreach (keys %$child_data) {
            $data{"$name/$_"} = $child_data->{$_};
        }
    }

    return \%data;
}

sub _dump_module {
    my ($self, $module, $data) = @_;
    my $s = "# This file is autogenerated by $0 at ".strftime("%Y/%d/%m %H:%M:%S" , localtime)."\n";

    $s .= "#! Name $module\n";
    $s .= "#! Version ".time()."\n\n";

    foreach my $k (sort keys %$data) {
        my $p = $k;
        my $v = $data->{$k};

        $p = "/$p";

        if ($module eq 'TREE') {
            $k = $p;
        } else {
            $k =~ s/\//./g;
            $p = "/onlineconf/module/$module$p";
        }

        $s .= "$k $v\n";
    }

    $s .= "#EOF";

    my $modified;

    if ($modified = $self->_module_modified($module, $s)) {
        my $filename = File::Spec->catfile($self->dir, "$module.conf");
        open my $f, '>:utf8', "${filename}_tmp" or die "Can't open file ${filename}_tmp: $!\n";
        print $f $s;
        close $f;
        rename "${filename}_tmp", $filename or die "Can't rename ${filename}_tmp to $filename: $!";
    }

    if ($self->cdb) {
        eval {
            $self->_dump_module_cdb($modified, $module, $data);
        };

        if ($@) {
            warn $@;
        }
    }

    return;
}

sub _module_modified {
    my ($self, $module, $content) = @_;
    my $current;
    my $filename = File::Spec->catfile($self->dir, "$module.conf");
    open my $f, '<:utf8', $filename or return 1;
    while (<$f>) {
        $current .= $_ unless /^#/;
    }
    close $f;
    $content =~ s/^#.*\n?//gm;
    return $content ne $current;
}

sub _dump_module_cdb {
    my ($self, $modified, $module, $data) = @_;
    my $f = File::Spec->catfile($self->dir, "$module");

    if (! $modified && -e "${f}.cdb") {
        return;
    }

    my $t = CDB_File->new("${f}_tmp.cdb", "${f}.$$") or die "Can't open cdb file: $!";

    foreach my $k (sort keys %$data) {
        my $p = $k;
        my $v = $data->{$k};

        $p = "/$p";
 
        if ($module eq 'TREE') {
            $k = $p;
        } else {
            $k =~ s/\//./g;
            $p = "/onlineconf/module/$module$p";
        }

        if ($k =~ s/:JSON$//) {
            $t->insert($k, "j$v");
        } else {
            $t->insert($k, "s$v");
        }
    }

    $t->finish();

    rename "${f}_tmp.cdb", "${f}.cdb" or die "Can't rename ${f}_tmp.cdb to ${f}.cdb: $!";

    return;
}

no Mouse;
__PACKAGE__->meta->make_immutable();

1;
